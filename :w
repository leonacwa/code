/* Minimum Cost
 * 最小费用最大流
 * */
#include <cstdio>
#include <cstring>

const int MAXN = 50005, MAXM = 300000;
const int INF = 99999999;

struct Edge {
	int to;
	int c, w;
	int next;
	Edge(int tto=0, int tc=0, int tw=0, int tn=-1) : to(tto), c(tc), w(tw), next(tn) {}
};
Edge E[MAXM];
int nE, V[MAXN]; // nE 边数，V[]顶点的边链表头

int pre[MAXN];
int path[MAXN];
int sp[MAXN]; // 源点到各个点的费用
int que[MAXN]; 
bool inq[MAXN];

void initNetwork(int n = MAXN) {
	memset(V, -1, sizeof(V[0]) * n);
	nE = 0;
}

void addEdge(int u, int v, int c, int w, int rc = 0) { // rc是反向弧的容量
	E[nE] = Edge(v, c, w, V[u]);
	V[u] = nE++;
	E[nE] = Edge(u, rc, -w, V[v]);
	V[v] = nE++;
}

/* SPFA，根据需要使用cnt[]数组统计顶点入队次数，入队次数>=n则表示存在负权环，
 * 也可以使用dfs深搜，如果遇到已经出现的点说明存在负权环
 * 实际中SPFA算法的效率不稳定，可以使用更加稳定的Dijkstra算法
 * */
bool SPFA(int n, int source, int sink) {
	int *fr = que, *ta = que, q_cnt;
	int qsum = 0;
	for (int i = 0; i < n; ++i) sp[i] = INF, inq[i] = false;
	pre[source] = -1;
	sp[source] = 0;
	*ta++ = source;
	q_cnt = 1;
	inq[source] = true;
	while (fr != ta) {
		if (fr == que + MAXN) fr = que;
		int u = *fr++;
		// LLL, Large Label Last 进行优化, 50%的速度提高
		double avg_x = q_sum*1.0 / q_cnt;
		inq[u] = false;
		--q_cnt;
		for (int i = V[u], v; i != -1; i = E[i].next) {
			v = E[i].to;
			if (E[i].c > 0 && sp[v] > sp[u] + E[i].w) {
				sp[v] = sp[u] + E[i].w;
				pre[v] = u;
				path[v] = i;
				if (false == inq[v]) {
					if (v == sink) return true;
					// SLF Smal Label First 距离更短的顶点在队列前，此优化效果非常明显, 15~20%的速度提高
					if (fr != ta && sp[*fr] > sp[v]) {
						fr--;
						if (fr < que) fr = que + MAXN - 1;
						*fr = v;
					} else {
						if (ta == que + MAXN) ta = que;
						*ta++ = v;
					}
					++q_cnt;
					q_sum += sp[v];
					inq[v] = true;
				}
			}
		}
	}
	return sp[sink] < INF;
}

int argument(int n, int source, int sink) {
	int delta = INF;
	for (int i = sink, e; pre[i] != -1; i = pre[i]) {
		e = path[i];
		if (delta > E[e].c) delta = E[e].c;
	}
	for (int i = sink, e; pre[i] != -1; i = pre[i]) {
		e = path[i];
		E[e].c -= delta;
		E[e^1].c += delta;
	}
	return delta;
}
// 最小费用最大流
void mincost_maxflow(int n, int source, int sink, int &flow, int &cost) {
	flow = 0, cost = 0;
	while ( SPFA(n, source, sink) ) {
		int delta = argument(n, source, sink);
		flow += delta;
		cost += sp[sink] * delta;
	}
}

int main() {
	int n, m, k;
	while (EOF != scanf("%d%d%d", &n, &m, &k)) {
		if (n == 0 && m == 0 && k == 0) break;
		int source = n*k + m*k;
		int sink = source + 1;
		int total = 0;
		initNetwork(sink + 1);
		for (int i = 0, c; i < n; ++i) {
			for (int j = 0; j < k; ++j) {
				scanf("%d", &c);
				total += c;
				addEdge(i*k+j, sink, c, 0);
			}
		}
		for (int i = 0, c; i < m; ++i) {
			for (int j = 0; j < k; ++j) {
				scanf("%d", &c);
				addEdge(source, n*k + i*k+j, c, 0);
			}
		}
		for (int c = 0, w; c < k; ++c) {
			for (int a = 0; a < n; ++a) {
				for (int b = 0; b < m; ++b) {
					scanf("%d", &w);
					addEdge(n*k + b*k+c, a*k+c, INF, w);
				}
			}
		}
		int cost, flow;
		mincost_maxflow(sink + 1, source, sink, flow, cost);
		if (flow == total) {
			printf("%d\n", cost);
		} else {
			puts("-1");
		}
	}
	return 0;
}
