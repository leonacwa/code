## Suffix Tree 后缀树

### 考虑子串匹配问题:  
给一个文本串T[1...m]， 要求在预处理O(m)时间下使得每个模板串P[1..n]可以在O(n)时间内匹配。  

相关链接  
http://blog.163.com/lazy_p/blog/static/13510721620108139476816/
http://blog.csdn.net/hgd250/article/details/3630039

原串的所有后缀都能由根节点到某个叶子节点路径上的字符组合起来得出。  

任何一个叶子节点所“代表”的字符串（根节点走到这个节点过程中边上字符构成的串）一定是原串的一个后缀（反过来则不一定）。  

### 后缀树中节点的分类  
 1. 一个叶节点. 这个是常识了, 图4中标号为1, 2, 4, 5的就是叶节点.
 2. 显式(explicit)节点：就是你在当前后缀树中看到的所有非叶子节点,该节点之后至少有两条边.
 3. 隐式(implicit)节点：路径压缩中被压缩掉的节点。隐式节点在某条表示序列的边上结束. 它表示后缀Trie中存在的由于路径压缩而剔除的节点. 在后缀树的构造过程中, 有时要把一些隐式节点转化为显式节点.

### 理解算法需要注意的  

http://blog.csdn.net/ljsspace/article/details/6596509

隐式后缀树(implicit suffix tree)：  
后缀可能终止于叶子结点，也可能隐藏在内部结点中。如果输入串中最后一个字符不同于其他字符，那么所有的后缀都终止于叶子结点，不会有后缀隐藏在内部结点中。这就是为什么ukk算法中最后一个字符必须是特殊字符的原因。  

阶段(phase)：  
在阶段i+1中，将考虑S[i+1]进来并将S[0...i+1]的所有后缀加入到上一个阶段i生成的隐式后缀树中，形成一个新的隐式后缀树。

扩展(extension)：  
在每个阶段中，需要将每一个后缀加入到上一个阶段的隐式后缀树中，每个后缀加入操作叫做extension j。例如要生成mississippi$的后缀树，在phase i+1=4时，需要将后缀missi,issi,ssi,si,i分别加入到phase 3生成的隐式后缀树中，换句话说，这个阶段中共有5个extensions，分别将子串S[j...4]加入到phase 3生成的隐式后缀树中，其中j的取值范围为[0...4]，。

后缀链(suffix link)：(Suffix Pointer)  
参考前面关于mcc算法的博文（注意：只有内部结点才有suffix link，叶子结点无需suffix link）。   (我理解是fail指针，与AC自动机相似)


一个英文资料：http://www.allisons.org/ll/AlgDS/Tree/Suffix/
